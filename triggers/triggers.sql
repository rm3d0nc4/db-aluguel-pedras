/*
========================================
||                                    ||
||      Trigger Validar Parceiro      ||
||                                    ||
========================================
*/


CREATE OR REPLACE FUNCTION T_VALIDACAO_PARCEIRO() 
RETURNS TRIGGER AS $$
	BEGIN
		PERFORM VALIDAR_EMAIL(NEW.EMAIL);
		PERFORM VALIDAR_TELEFONE(NEW.TELEFONE);

		IF(NEW.TIPO_PESSOA = 1) THEN
			PERFORM VALIDAR_CPF(NEW.CPF_CNPJ);
		ELSE
			PERFORM VALIDAR_CNPJ(NEW.CPF_CNPJ);
		END IF;
        RAISE NOTICE 'PARCEIRO CADASTRADO COM SUCESSO!';
		RETURN NEW;
	END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_PARCEIRO BEFORE INSERT OR UPDATE ON PARCEIRO FOR EACH ROW EXECUTE PROCEDURE T_VALIDACAO_PARCEIRO();

/*
========================================
||                                    ||
||      Trigger Validar Analista      ||
||                                    ||
========================================
*/


CREATE OR REPLACE FUNCTION T_VALIDACAO_ANALISTA()
RETURNS TRIGGER AS $$
    BEGIN
        PERFORM VALIDAR_CPF(NEW.CPF_ANALISTA);
        RAISE NOTICE 'ANALISTA CADASTRADO COM SUCESSO!';
        RETURN NEW;
    END;

$$  LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_ANALISTA BEFORE INSERT OR UPDATE ON ANALISTA FOR EACH ROW EXECUTE PROCEDURE T_VALIDACAO_ANALISTA();

/*
========================================
||                                    ||
||   Trigger Atualizar Valor Total    ||
||             Do Pedido              ||
========================================
*/

CREATE OR REPLACE FUNCTION T_ATUALIZAR_VALOR_TOTAL_PEDIDO() 
RETURNS TRIGGER AS $$
	DECLARE
	VAR_NOVO_VALOR_TOTAL_PEDIDO NUMERIC(10,2);
	
	BEGIN
		SELECT COALESCE(SUM(VALOR_DIARIA * (DATA_FINAL - DATA_INICIAL)), 0) INTO VAR_NOVO_VALOR_TOTAL_PEDIDO FROM LISTA_PEDRAS_PEDIDO NATURAL JOIN PEDRA WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

		UPDATE PEDIDO SET VALOR_TOTAL_PEDIDO = VAR_NOVO_VALOR_TOTAL_PEDIDO WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);
		RETURN COALESCE(NEW, OLD);
	END;

$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_ATUALIZAR_VALOR_TOTAL_PEDIDO AFTER INSERT OR UPDATE OR DELETE ON LISTA_PEDRAS_PEDIDO FOR EACH ROW WHEN (NEW) EXECUTE PROCEDURE T_ATUALIZAR_VALOR_TOTAL_PEDIDO();

-- DROP TRIGGER TRIGGER_ATUALIZAR_VALOR_TOTAL_PEDIDO ON LISTA_PEDRAS_PEDIDO; -- Bloqueia a função FATURAR_PEDRA

/*
========================================
||                                    ||
|| Trigger Atualizar Data Vencimento  ||
||     Do Pagamento da Comissão       ||
========================================
*/

CREATE OR REPLACE FUNCTION T_ATUALIZAR_DATA_VENCIMENTO_PAGAMENTO_COMISSAO() 
RETURNS TRIGGER AS $$
	DECLARE
	VAR_MAX_DATA_FINAL DATE;
	
	BEGIN
		SELECT COALESCE(MAX(DATA_FINAL), CURRENT_DATE) INTO VAR_MAX_DATA_FINAL FROM LISTA_PEDRAS_PEDIDO WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);
		UPDATE PEDIDO SET DATA_VENCIMENTO_PAGAMENTO_COMISSAO =(VAR_MAX_DATA_FINAL + 10)::TIMESTAMP WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

		RETURN COALESCE(NEW, OLD);
	END;

$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_ATUALIZAR_DATA_VENCIMENTO_PAGAMENTO_COMISSAO AFTER INSERT OR UPDATE OR DELETE ON LISTA_PEDRAS_PEDIDO FOR EACH ROW EXECUTE PROCEDURE T_ATUALIZAR_DATA_VENCIMENTO_PAGAMENTO_COMISSAO();

-- DROP TRIGGER  TRIGGER_ATUALIZAR_DATA_VENCIMENTO_PAGAMENTO_COMISSAO ON LISTA_PEDRAS_PEDIDO;  -- Bloqueia a função FATURAR_PEDRA


/*
===========================================
||                                       ||
||  Trigger Para Bloquear Atualização    ||
||   Do Faturento Enquanto o Pedido      ||
|| Está Em Andamento ou Já Foi Encerrado ||
===========================================
*/

CREATE OR REPLACE FUNCTION T_BLOQUEAR_FATURAMENTO() RETURNS TRIGGER AS $$
	DECLARE VAR_NUMERO_NOTA UUID;

	BEGIN
		SELECT NUMERO_NOTA INTO VAR_NUMERO_NOTA FROM PEDIDO WHERE ID_PEDIDO = NEW.ID_PEDIDO;
		IF( NEW.FATURAMENTO != OLD.FATURAMENTO AND VAR_NUMERO_NOTA IS NULL) THEN
			RAISE EXCEPTION 'NÃO É POSSÍVEL ATUALIZAR O FATURAMENTO ENQUANTO O PEDIDO NÃO FOR PAGO.';
		END IF;

		IF(OLD.DATA_FINAL < CURRENT_DATE) THEN
			RAISE EXCEPTION 'NÃO É POSSÍVEL ATUALIZAR O FATURAMENTO APÓS A DATA FINAL';
		END IF;

		RETURN NEW;
	END;

$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_BLOQUEAR_FATURAMENTO_ENQUANTO_PEDIDO_ESTA_EM_ANDAMENTO BEFORE UPDATE ON LISTA_PEDRAS_PEDIDO FOR EACH ROW EXECUTE PROCEDURE T_BLOQUEAR_FATURAMENTO();


/*
===========================================
||                                       ||
||  Trigger Para Bloquear Atualização    ||
||   De uma Pedra em um Pedido Após o    ||
||        Pagamento do Aluguel           ||
===========================================
*/

CREATE OR REPLACE FUNCTION T_BLOQUEAR_ATUALIZACAO_PEDRA_PEDIDO() 
RETURNS TRIGGER AS $$
	DECLARE 
	VAR_NUMERO_NOTA UUID;
	VAR_DADOS_ATUALIZADOS BOOL;
	BEGIN
		SELECT NUMERO_NOTA INTO VAR_NUMERO_NOTA FROM PEDIDO WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

		IF VAR_NUMERO_NOTA IS NOT NULL THEN
			IF TG_OP = 'UPDATE' THEN
				IF(NEW.FATURAMENTO = OLD.FATURAMENTO) THEN
					RAISE EXCEPTION 'NÃO É POSSÍVEL ATUALIZAR UMA PEDRA APÓS O PAGAMENTO DO PEDIDO';
				END IF;
			ELSIF TG_OP = 'INSERT' THEN
				RAISE EXCEPTION 'NÃO É POSSÍVEL INSERIR UMA PEDRA APÓS O PAGAMENTO DO PEDIDO';
			ELSIF TG_OP = 'DELETE' THEN
				RAISE EXCEPTION 'NÃO É POSSÍVEL REMOVER UMA PEDRA APÓS O PAGAMENTO DO PEDIDO';
			END IF;			
		END IF;
		RETURN NEW;
	END;

$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_BLOQUEAR_ATUALIZACAO_PEDRA_PEDIDO BEFORE INSERT OR UPDATE OR DELETE ON LISTA_PEDRAS_PEDIDO
FOR EACH ROW EXECUTE PROCEDURE T_BLOQUEAR_ATUALIZACAO_PEDRA_PEDIDO();

-- DROP TRIGGER TRIGGER_BLOQUEAR_ATUALIZACAO_PEDRA_PEDIDO ON LISTA_PEDRAS_PEDIDO;

/*
===========================================
||                                       ||
||  Trigger Para Bloquear Atualização    ||
||          De um Pedido Após o           ||
||         Pagamento do Aluguel          ||
===========================================
*/

CREATE OR REPLACE FUNCTION T_BLOQUEAR_ATUALIZACAO_PEDIDO() 
RETURNS TRIGGER AS $$
	DECLARE VAR_NUMERO_NOTA UUID;
	BEGIN
		SELECT NUMERO_NOTA INTO VAR_NUMERO_NOTA FROM PEDIDO WHERE ID_PEDIDO = NEW.ID_PEDIDO;
		IF VAR_NUMERO_NOTA IS NOT NULL THEN
			IF TG_OP != 'UPDATE' OR NEW.DATA_PAGAMENTO_COMISSAO = OLD.DATA_PAGAMENTO_COMISSAO OR NEW.VALOR_COMISSAO = OLD.VALOR_COMISSAO THEN
				RAISE EXCEPTION 'NÃO É POSSÍVEL MODIFICAR UM PEDIDO APÓS O PAGAMENTO';
			END IF;
		END IF;
		RETURN COALESCE(NEW, OLD);
	END;

$$ LANGUAGE 'plpgsql';

CREATE OR REPLACE TRIGGER TRIGGER_BLOQUEAR_ATUALIZACAO_PEDIDO BEFORE INSERT OR UPDATE OR DELETE ON PEDIDO
FOR EACH ROW EXECUTE PROCEDURE T_BLOQUEAR_ATUALIZACAO_PEDIDO();

DROP TRIGGER TRIGGER_BLOQUEAR_ATUALIZACAO_PEDIDO ON PEDIDO;


CREATE OR REPLACE FUNCTION T_ATUALIZAR_VALOR_COMISSAO() RETURNS TRIGGER AS $$
	BEGIN
		IF TG_OP = 'UPDATE' THEN
			UPDATE PEDIDO SET VALOR_COMISSAO = 
			(SELECT SUM(FATURAMENTO) * 0.1  FROM LISTA_PEDRAS_PEDIDO WHERE ID_PEDIDO = NEW.ID_PEDIDO);

		END IF;
		RETURN NEW;
	END;

$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE TRIGGER TRIGGER_ATUALIZAR_VALOR_COMISSAO AFTER UPDATE ON LISTA_PEDRAS_PEDIDO FOR EACH ROW EXECUTE PROCEDURE T_ATUALIZAR_VALOR_COMISSAO();

-- DROP TRIGGER TRIGGER_ATUALIZAR_VALOR_COMISSAO ON LISTA_PEDRAS_PEDIDO;